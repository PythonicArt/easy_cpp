


机器内存由 一系列的 机器字组成。
机器字就是 一个地址对应的单位长度。 比如 64位的机器， 一个地址索引的数据就是64位。

运行时栈。
    
    任何语言的程序，都需要有一个实时的管理系统来支撑， 有效地为程序分配内存， io等资源。 这个叫做运行时系统或是虚拟机。

    程序调用栈
        每个进程都有一个函数调用栈。 每发起一个函数调用， 就在call stack中增加一个该函数的frame. 可以知道， 栈顶就是当前正在执行的 函数。

        frame包含
            执行时 变量的值和程序计数器

            程序计数器 PC
                是 该函数经过编译之后 机器指令 的位置。

            该值说明 一个函数内部发起函数调用的位置。 当调用的函数执行完毕并返回， 可以通过该值来确定下一步从哪里开始执行。


    函数调用的过程

    递归的实现
        自我调用就是不断地增加frame,压入栈。直到达到返回条件， 则逐一弹出返回。

        所以递归的空间复杂度就是 栈元素的最大值。


内存堆
    内存中除去  代码区域， 调用栈 的额外的区域， 可以用于存储对象。

    为什么要有？
        函数内部的frame对外部是不可见的，每一个局部对象都有实际的值。并且该区域随着函数的调用和返回进行分配和释放。取决于有多少函数调用和函数什么时候结束。

        堆区域是一个动态的区域， 它可以供任何函数申请资源， 函数局部变量的值是地址， 通过地址索引到具体的堆区域。
        这样， 不同函数内部的变量可以索引到同一片区域， 实现了资源的重复利用。

        假设没有堆区域， 每个函数内部的局部变量都自己申请空间。 那么相同的资源就会存在多遍。 严重地降低了资源的利用率。


    管理方式。
        分块管理。 这个块即可以是 等大小的， 也可以是 不等大小的。

        将所有的块链接 形成链表

        由于 不同的对象的大小是不同的, 而且具体多大也是不可预计的。 
        
        内存残片(fragmentation) 的产生
            internal fragmentation 
                申请指定大小的空间， 但是并没有完全使用

            external fragmentation
                未分配的空间和已使用的空间交替出现。形成原因是链表中间的区域被提前释放。 

                如果出现很多的 external fragmentation, 而且每一个大小都不一致，一些区段可能无法满足大小， 为新对象分配内存时将会增加检索时间。
                理想的状态是 没有 external fragmentation。


        内存分配算法
            best-fit 
                从头开始检索，找到最接近 所需要的空间大小的区段。 
                该方式每次都是申请差不多合适的， 所以会产生更小的 external fragmentation, 导致最后无法被利用。        
            first-fit
                找到第一个满足 申请空间大小的区段。
                这个是快速的，不需要完成遍历。 但是每次产生的 external fragmentation都靠前， 也就是增加fragmentation的数量。降低了下一次的检索速度
            next-fit
                同first-fit一样， 找到第一个满足的区段。 但是开始检索的位置是 上一次成功申请的位置的下一个位置。
                这个是first-fit的改进，降低了平均检索时间。
            worst-fit
                和best-fit刚好相反， 找到可分配空间最大的区段。看似好像很没有效率， 因为小的不被利用。 但是如果采用 优先队列管理，效率优于链表。同时， 保证了external fragmentation尽可能的大， 而且尽可能地连续。

        垃圾收集 garbage collection
            堆区域为资源共享提供了实现方式， 何时对资源进行释放是一个核心的问题。

            以c++为首的语言， 讲究严谨与效率。 对于资源申请者， 有义务及时释放资源。同时，及时地清理不会影响到其他申请者。
            
            以java为首的语言， 讲究自由与包容。 用户（这里指虚拟机的用户，也就是程序员）可以只申请资源， 而何时释放由虚拟机判断。 用户可以省下精力， 而不用去因为资源是否得到正确释放而苦恼。虚拟机定期进行垃圾回收， 这个时候讲暂停所有正在执行的程序。 将已被申请但是没有再被引用的空间释放掉。 并且重新整理一下内存块链表， 将可分配的块和已分配的块都变得更加紧凑。
            好一个中断所有程序， 想象一下， 双十一的时候你正在抢一双鞋子， 但是系统此时正在进行垃圾回收。 抱歉， 打扰了。看来双十一的前几个小时， 阿里应该把垃圾回收开关给关闭了。

            所以，有利也有弊。 c++之所以快一点， 在于它将java的统一垃圾回收 变成 分期处理(就是每个程序自己处理)相当于分期付款。


        垃圾回收算法
            堆空间区域的使用， 本质上是 栈区域的变量 对 堆区域的引用。对于堆区域的某个对象--一段地址， 如果一直被引用，则该对象还有生存的必要。 反之， 应该清除。

            mark-sweep algorithm
                栈区域的每个变量 被称为  root object
                堆区域的每一个对象 被称为 live object, 每个对象有一个标记 mark, 标识该对象是否 live
                
                垃圾回收时间到来， 暂停所有线程， 

                 引用即可以来自 root object 对 live object的引用， 也可以来自 不同 live object 之间的引用。 这从逻辑上可以看成是一个有向图。

                每一个root object 和 live object 是有向图的 结点， 每一个引用是有向图的 边。

                mark-phase
                    并将所有root object mark标记置 live
                    清除所有 live object mark 标记

                    从root object 出发对有向图执行 dfs遍历。 所有经过的节点 mark标记置 live

                    经过一趟遍历之后， 我们可以对所有live object遍历， 释放那些 unlive 的对象

                sweep-phase
                    合并所有已收集的空间， 使其成员一个连续的区域。这样，消除了 external fragmentation.

                    这一步涉及到对象的移位， 从而live object引用的地址也要对应修改，如果移位操作很多， 这一步是很耗时间的。
                    想像一下， 移除一个很大的数组的首元素的移位操作。
                    所以， 可以把该操作放在系统很休闲的时候做， 而无需每次垃圾收集都做。

                垃圾回收完成， 恢复所有线程。


















