map与外存数据检索

对于无法全部放入内存的大数据的管理和操作。

考虑存储机制， 外存数据时按 磁盘块  为单位 调入内存。
内存与外存数据的交互是一个很耗时的操作， 从而数据结构的优劣的评价标准就是 内外存调换的次数， 即io时间复杂度。

一些实现方式

非排序链表
	在内存中, 查询和修改都是O(n)， 插入O(1)

	如果一个磁盘块可以存放 B个节点，则 查询需要的io次数为 O(n/B)

排序数组
	在内存中, 查询可以使用 二分查找， o(logn), 但只能是一个磁盘块数据的二分查找
	修改和插入 需要移动元素， 而移动元素为O(n), 即io次数也为 O(n/B)

树形结构
	内部节点只有关键字， 关键字对应的地址，和小于关键字内容的block地址。

平衡树(平衡搜索树， 红黑树)
	对于外存数据， 最坏的情况， 如果每个节点都不在同一个内存块中， 此时时间复杂度O(logn)


多路搜索树 (a, b)树
	多路搜索树的改善在于 降低了树 的高度

	每个节点的子节点数，范围 [a, b]
	所有的叶子节点都在同一层上， 即拥有相同的深度。
	a,b关系  2<=a<=(b+1)/2

	考虑高度为 h 叶子节点个数。
	最小
		m = n+1 = a^h  >= 2a^h
	最大
		m = n+1 = b^h
	得到
		log(n+1)*1/logb <= h <= ( log((n+1)/2)*1/loga ) + 1
		h = O(logn * 1/ loga)

		也就是高度缩小了 loga 倍

	对于多路搜索树的一个节点， 自身也是一个map， 所以最好使得一个 内存块就能存放map 的全部节点

	对于插入操作， 找到对应的节点之后， 如果当前节点元素个数为b， 则需要 分裂调整。
	当前节点分裂成两半， 移动一个元素给父节点。 再逐级往上调整

	对于删除操作， 如果删除后节点元素小于a, 即a-1， 则需要调整。
	通过兄弟节点借元素或和兄弟节点合并了调整。

	以上调整需要进行多次的 磁盘io， 而次数成比例与 树的高度
	所以 以上操作的时间复杂度
		O(logn * 1/ loga)


	B-Tree
		a=ceil(d/2) b=d, d成比例与B， B是磁盘块的大小， 可以灵活的调整。
		由于 a, b 都B成比例， 则最后的复杂度为

		O(logn / logB)
