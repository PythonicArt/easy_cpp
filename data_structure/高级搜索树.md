# splay tree
    一种二叉搜索树, 但是没有平衡的要求
    每进行一次操作, 查询, 新增或是移除节点, 都将要操作的节点通过变形移到顶层

    这种树假设一次操作之后， 在接下来的一个时间段内会被连续地执行到, 由于第一次做了调整, 后面的操作就是常数级别的, 从而减少了总的操作时间

# 多路搜索树
    1. 每个内部节点至少有两个子节点, 即至少有一个元素
    2. 每个内部节点存储一组已经排好序的序列, (k1, X1, n1)...(kd-1, Xd-1, nd-1), (infinite, x, nd)
        Ni 指向下一个节点, 该节点的所有key都小于或等于ki

    性质:
        外部节点数量 = 条目数 + 1
        数学归纳法

    多路搜索树的实现
        每个内部节点是一组元素的集合, 考虑其需要搜索， 每一个节点也可以使用一个 搜索树 来实现
        也可以直接使用线性结构

    搜索
        从根节点开始, 对每一个节点的序列查找, 如果找到, 则返回
        否则找到 ki, ki为序列中大于k的最小值, 进入到其索引的节点, 继续查找
        如果遇到外部节点， 则完全返回

    时间复杂度
        搜索树高度为 h, 最坏的情况从上到下 最后一层
        每一层都在一个序列中搜索， 为 logd 或 d
        总的复杂度为  h*logd h*d

    以上, 时间效率都和高度有关, 所以: 如果高度尽可能小, 则时间效率就尽可能高

    (2, 4) 树
        1. 每个内部节点最多 四个孩子, 也就是最多有3个key
        2. 所有的外部节点在同一高度层

        这样就限制了高度， 从而提升了时间效率

    考虑最大高度,
        每一层两个节点, 外部节点数量为  2^h
        每一层四个节点, 外部节点数量为  4^h
        则   2^h <= n+1 <= 4^h

        h<= log(n+1) h>= 1/2 * log(n+1)

    该时间效率是 O(logn)

    插入
        需要考虑节点条目大于3的情况, 需要分裂节点
        分成
            k1 k2 | k3 | k4
            k1 | k2 | k3 k4
        把第三个节点移到父节点去, 在父节点循环这个操作
        如果遇到根节点, 则新建一个节点, 放k3

    移除
        先找到key所在的节点 v
        如果v的子节点都是 外部节点, 则直接移除
        否则,
            从以 k所在节点 为根节点的子树中, 找左子树最右(或 右子树最左)的且子节点都是外部节点的 节点v, 将该节点的最后一个entry与要删除的entry替换
        从而将问题转换成 删除v节点中的最后一个entry, 也就是前一种情况

        underflow:
            当节点只有一个entry时， 删除会破坏基本性质, 当前节点会变为外部节点， 而与其他外部节点不在同一层
            此时需要调整

            transfer:
                如果直接的兄弟节点entry数量>=2, 则需要借用entry
                从父节点中的移交一个entry给v
                为了保持父节点的树形结构和key的顺序性, 兄弟节点的移交一个entry 给父节点
            fusion
                如果只有一个兄弟节点， 或entry数量都是1, 则与直接地子节点合并,
                此时破坏了父节点的结构(由于子节点的一层因为合并少了一条分支， 那么父节点就有一个是多余的)，
                从父节点中将合适的entry移入合并的节点

            如果父节点因为移除变空, 则在该层上, 循环继续往上执行上述操作
            如果根节点被移空 ，则合并的节点成为新的而根节点
