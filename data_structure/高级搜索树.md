# splay tree
    一种二叉搜索树, 但是没有平衡的要求
    每进行一次操作, 查询, 新增或是移除节点, 都将要操作的节点通过变形移到顶层

    这种树假设一次操作之后， 在接下来的一个时间段内会被连续地执行到, 由于第一次做了调整, 后面的操作就是常数级别的, 从而减少了总的操作时间

# 多路搜索树
    1. 每个内部节点至少有两个子节点
    2. 每个内部节点存储一组已经排好序的序列, (k1, X1, n1)...(kd-1, Xd-1, nd-1), (infinite, x, nd)
        Ni 指向下一个节点, 该节点的所有key都小于或等于ki

    搜索
        从根节点开始, 对每一个节点的序列查找, 如果找到, 则返回
        否则找到 ki, ki为序列中大于k的最小值, 进入到其索引的节点， 继续查找
        如果遇到外部节点， 则完全返回

    以上, 时间效率都和高度有关, 所以: 如果高度尽可能小, 则时间效率就尽可能高

    性质:
        外部节点数量 = 条目数 + 1

    (2, 4) 树
        1. 每个内部节点最多 四个孩子, 也就是最多有3个key
        2. 所有的外部节点在同一高度层

    该时间效率是 O(logn)

    插入
        需要考虑节点条目大于3的情况, 需要分裂节点
        把第三个节点移到父节点去, 在父节点循环这个操作
        如果遇到根节点, 则新建一个节点， 放k3

    移除
        先找到key所在的节点 v
        如果v的子节点都是 外部节点, 则直接移除
        否则， 从以 k为根节点的子树中， 找最右的且子节点都是外部节点的 节点v, 将该节点的最后一个entry与要删除的entry替换
        从而将问题转换成 删除v节点中的最后一个entry, 也就是前一种情况

        underflow:
            当节点只有一个entry时， 删除会破坏基本性质, 当前节点会变为外部节点， 而与其他外部节点不在同一层
        transfer:
            如果直接的兄弟节点entry数量>=2, 则需要借用entry， 为了保持父节点的树形结构和key的顺序性, 需要从父节点中的移交一个entry给v, 兄弟节点的移交一个entry 给父节点
        fusion
            如果只有一个兄弟节点， 或entry数量都是1, 则与直接地子节点合并, 此时破坏了父节点的结构， 从父节点中将最大的entry移入新建的节点

        如果父节点也只有一个节点， 则循环继续往上执行上述操作
