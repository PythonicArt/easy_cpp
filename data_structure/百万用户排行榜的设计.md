海量拥护排行榜设计
用户 2亿
积分范围  0-100万

大规模， 高并发
https://blog.csdn.net/fangjian1204/article/details/38733997

操作

1. 根据某个用户的积分 查看 排名
2. 积分变动 对 排行榜的 改动
3. 取top-k的排名

方案一
	直接数据表
	id score
	select score, (select count(distinct score) from Score s where score>s.score ) + 1 as RANK from Score s
	查询排名需要每次计算

	单个表存放所有用户数据， 计算量大。 对于并发需求会有表的锁定，
	建立索引并不能带来太大的改善， 很多人可能积分相同。

方案二
	分表， 将用户根据 分数段 划分子表
	额外维护一个 分区段 的人数表， 当有玩家积分出现跨区段的变动， 对应的积分段人数也做调整

	计算排名 为 当前分表内的排名+比当前分数段高的分表的记录数

	自定义分数区间。 可以均匀分区， 也可以根据分布来划分。但是由于数据时动态的， 分区的分布也是动态的， 不够灵活。
	可能会导致某个分区的人数过多， 也就退化成了单张表的情况。

	树形区间。 从上到下不断地 二分区间。 最底层 为1分 1分的区间。 每个节点维护当前区间的人数和人员信息。
	当前节点的人数为所有子节点人数的和。
	根据积分查排名；
		通过查询树结构， 累加有效节点的人数获得排名
	积分变动：s->t
		从积分s的叶子节点开始逐一往上 人数-1， 再从根节点开始， 通过t的查询路径往下， 人数+1
	topk
		查询顶部的节点即可

	树形区间使得查询效率由  O(n) 变成了 O(logn), 二者的效率差距需要数据达到一定的数量级。

方案三
	排名数组。 每一分对应一个排名，和当前积分下的人员信息
	一个用户 从 95 -> 98 分， 95以下和98及以上的排名不受影响。 95-97的排名都要+1  

	该方案 较符合 显示情况， 积分变化范围不会很大，只是在一个很小的范围内变动


问题
索引的结构
索引带来的查询效率的提升
全局扫描 or 索引查询
