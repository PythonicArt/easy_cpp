快速排序的思想

一轮操作
    找一个哨兵值, 把小于哨兵值得元素都移动到左边， 大于哨兵值得元素都移动到右边去
    一轮结束后， 哨兵可以放到正确的位置上。

    重复多轮， 直到遇到单元数的列表即可停止

需要多少轮
    轮次决定了运行效率

    最理想的
        每一次都放到中间的位置， 即形成一棵二叉树的形式
        那么二叉树的高度就是轮次 logn
        此时效率为 n*logn

    最不理想的
        每一次都放到第一个或是第二个位置， 即形成一个列表的形式
        列表的长度就是轮次， n
        n*n

topK的思想

需要快速地找到列表中前k个元素

题目没有讲一个前提， 那就是前k个元素是否要有序

1. 可以先排序，然后取前k个元素. 效率为排序的效率, 最好为 n*logn
2. 参考快排的思想， 找一个哨兵值, 进行多轮的筛选
    可以看到， 每一轮都会有几个元素被找出来, 假如第一轮就找到, 那就ok
    如果没有找到，那就是缩小了范围， 继续找, 直到找到
    最理想的 O(n)

3.维护一个n个元素的有序结构，依次往里添加, 非常标准的o(n)
    这个有序结构可以是 列表， 也可以是 堆(树形结构)
