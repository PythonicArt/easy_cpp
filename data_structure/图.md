# 基本概念汇总

顶点
顶点的邻接
顶点的度, 出度, 入度

关于顶点度的3个性质

边

有向图
无向图

简单图
无环图

路径
连接图
    任何两个顶点有路径
非连接图

子图

生成子图:
    包含图的所有顶点

最大生成子图
    包含顶点最多的连接子图

森林
树

图 的顶点与边的关系
连接图 m >= n-1
树 m = n-1
森林 m <= n-1

# 图 的ADT
顶点
incidentEdges() 返回 顶点的所有邻接边
isAdjacentTo(v) 是否和v邻接

边
endVertices() 返回当前边的所有顶点
opposite(v) 当前边除v之外的另一个顶点, 如果v不属于当前边的顶点， 则报错
isAdjacentTo(f) 与边f是否邻接， 即是否有公共顶点
isIncidentOn(v) 是否有顶点v

图
vertices()
edges()
insertVertex(x)
insertEdge(v, w, x)
eraseVertex(v)
eraseEdge(e)

# 实现图 的数据结构
## 1. 边表集
顶点集合 V, 存放所有顶点, 每个顶点包括以下内容
    element x
    position index位于集合中V的位置索引

边集合, 存放所有边， 每条边a-b包含以下内容
    element e
    vertex a, V中节点的索引
    vertex b
    position

两个集合可以使用 双端链表实现, 也可使用dictionary

### 局限性
通过边找节点是可以的， 但是通过节点找其所邻接的边， 就比较差劲了。 需要遍历整个E，找到包含要查找的顶点的 边
同时， 要找到 v.isAdjacentTo(w), eraseVertex(v), 也需要遍历, 因为无法直接定位和顶点相关的所有边。

## 2. 邻接list
基于1的局限性， 新加一个关系， 存放顶点v 相关的所有边

顶点v新增一个元素， 存放其邻接表的索引， 以查询其邻接边

集合I, 存放和顶对v相关的所有边， 包含以下内容
    edge 对应的边在集合E中的索引

边 e 增加元素
    顶点 a 的领接表中 与该边对应的元素
    顶点 b 的领接表中 与该边对应的元素

优化之后， 上述和顶点相关的操作， 只需查找其领接表即可， 时间复杂度 O(d), d为顶点的度

## 3. 邻接 matrix
增加一个邻接矩阵， 让上述查询变为 O(1)
有一些局限
1. 邻接表较为庞大， O(n^2)
2. 增加和删除新的节点， 需要重新构造邻接表.
3. v.incidentEdges() 需要遍历邻接矩阵的某一行, 时间效率为 O(n)

# 图的遍历

DFS BFS
算法思想
时间复杂度

	解决的问题
		判断图是否连通
			一次遍历， 判断是否所有节点都被访问
		求连通子图的个数
			多次遍历， 直到所有节点都被访问
		求生成树
			首次访问的边组成的树就是生成树
		求两个节点的路径
			从一个节点开始dfs，每遇到一个节点就加入path, 如果某个节点访问完毕还没有遇到目标节点， 则从path中退出。 遇到目标节点就返回
		求图中的 环
			dfs, 每遇到一个节点就 加入 path, 如果在未访问的边中出现了 已经访问的节点，则该节点就是环的开始。从开始节点到当前节点就是一个环。
			去除path中起始节点之前的所有节点，环中的节点都被保留

# 有向图
强连接性 strongly connected

transitive closure
G- 如果是G 的传递闭包， G- 包含 G 的所有顶点
G中任何两个节点 u v 只要存在路径, 在G-中 就存在边 (u, v)

有向图的问题
	传递闭包
		dfs的解法
		动态规划的解法
	无环有向图的拓扑排序
    

# 图的两个重要的问题

单源最短路径
问题描述
	任意选一个节点v， 计算该节点到其他节点的最短路径和最短路径长度
Dijkstra 算法思想
	贪心思想， 从邻接的节点开始计算， 逐一找到最短代价的节点。
	初始，D[v] = 0，D[w]为v到该节点的 路径长度 cost, 其余为正无穷。
	维护一个优先队列 Q，元素为{D[w], w}
	同时有一个属性 path，存放v到该节点的最短路径 P[w], 初始化 P[v] = {v}, 其余均为[]
	不断地从Q中找到key最小的元素， {D[u], u},
	对每一个 与 u 相邻接的 且还在优先队列Q中的 节点 w
		if D[u] + cost(u, w) < D[w]
			D[w] = d[u] + cost(u, w)
			P[w] = P[u] + [w]
	最后得到的D, P 就是v到各个节点的最短路径长度，和最短路径

伪代码

时间复杂度
	A 优先队列(堆)的初始化 n个节点， O(n*logn)
	B 取出一个最小的元素 logn
	C 对所有的邻接节点做更新  Degree(u)*logn
	A + B + C = A + (n+Sum(Degree))*logn = O((n+m)logn)
	O(n^2*logn) wrost case

	如果使用普通的数组， 每次取元素是 常量级， 而更新之后的排序是O(n^2)/O(n*logn)
	考虑更新完所有邻接边再排序， 即 n*n^2 = O(n^3)


最小生成树
问题描述
	对于 无向有权树， 其最小生成树为 权重之和最小的生成树

Kruskal 算法思想
	贪心思想， 每次加入一条权重最短的边，重复n-1次， 直到获得最小生成树
	初始， 每一个节点 各自 为一个集合
	维护一个 优先队列， 元素为 {D[e], e}, D[e]为 每一条边的 权重, e为每一条边
	每次取出一个最小的元素 {D[e], e}, 获得该边的两个节点  a, b
	维护一个边的集合 T， 存放最小生成树的所有边
	如果 a, b 处于不同集合  C(a), C(b),
		合并两个集合 C(a) + C(b)
		将 e 加入 T
	如果处于相同集合
		不做任何操作

	T 即是 最小生成树

Prim 算法思想
	贪心思想， 随机选一个节点v 做起始节点
	D[w]为 任意节点 到该节点的 路径长度 cost,
	初始D[v] = 0， 其余为正无穷。
	维护一个优先队列 Q，元素为{D[w], w, e}
	维护一个边的集合 T， 存放最小生成树的所有边
	每次从Q中取出一个最小的元素{D[u], u, e}
		将e加入T
		对于u的每一条邻接边 e (u, w), 且 w在Q中
		if cost(u, w) < D[w]
			D[w] = cost(u, w)
			更新Q {D[w], w, e(u, w)}

	T 即是 最小生成树

伪代码
时间复杂度
	A 优先队列(堆)的初始化 n个节点， O(n*logn)
	B 取出一个最小的元素 logn
	C 对所有的邻接边做更新  Degree(u)*logn
	A + B + C = A + (n+m)*logn
