# 基本概念汇总

顶点
顶点的邻接
顶点的度, 出度, 入度

关于顶点度的3个性质

边

有向图
无向图

简单图
无环图

路径
连接图
    任何两个顶点有路径
非连接图

子图

生成子图:
    包含图的所有顶点

最大生成子图
    包含顶点最多的连接子图

森林
树

图 的顶点与边的关系
连接图 m >= n-1
树 m = n-1
森林 m <= n-1

# 图 的ADT
顶点
incidentEdges() 返回 顶点的所有邻接边
isAdjacentTo(v) 是否和v邻接

边
endVertices() 返回当前边的所有顶点
opposite(v) 当前边除v之外的另一个顶点, 如果v不属于当前边的顶点， 则报错
isAdjacentTo(f) 与边f是否邻接， 即是否有公共顶点
isIncidentOn(v) 是否有顶点v

图
vertices()
edges()
insertVertex(x)
insertEdge(v, w, x)
eraseVertex(v)
eraseEdge(e)

# 实现图 的数据结构
## 1. 边表集
顶点集合 V, 存放所有顶点, 每个顶点包括以下内容
    element x
    position index位于集合中V的位置索引

边集合, 存放所有边， 每条边a-b包含以下内容
    element e
    vertex a, V中节点的索引
    vertex b
    position

两个集合可以使用 双端链表实现, 也可使用dictionary

### 局限性
通过边找节点是可以的， 但是通过节点找其所邻接的边， 就比较差劲了。 需要遍历整个E，找到包含要查找的顶点的 边
同时， 要找到 v.isAdjacentTo(w), eraseVertex(v), 也需要遍历, 因为无法直接定位和顶点相关的所有边。

## 2. 邻接list
基于1的局限性， 新加一个关系， 存放顶点v 相关的所有边

顶点v新增一个元素， 存放其邻接表的索引， 以查询其邻接边

集合I, 存放和顶对v相关的所有边， 包含以下内容
    edge 对应的边在集合E中的索引

边 e 增加元素
    顶点 a 的领接表中 与该边对应的元素
    顶点 b 的领接表中 与该边对应的元素

优化之后， 上述和顶点相关的操作， 只需查找其领接表即可， 时间复杂度 O(d), d为顶点的度

## 3. 邻接 matrix
增加一个邻接矩阵， 让上述查询变为 O(1)
有一些局限
1. 邻接表较为庞大， O(n^2)
2. 增加和删除新的节点， 需要重新构造邻接表.
3. v.incidentEdges() 需要遍历邻接矩阵的某一行, 时间效率为 O(n)

# 有向图
强连接性 strongly connected

transitive closure
G- 如果是G 的传递闭包， G- 包含 G 的所有顶点
G中任何两个节点 u v 只要存在路径, 在G-中 就存在边 (u, v)

# 图的遍历
DFS的过程
DFS的时间复杂度
DFS 能够解决的问题
1. 判断图的连通性, 求连通子图的个数, 求的最大生成子图
2. 求连通图的生成树
4. 计算两个结点的路径(如果可达的话)
5. 判断图是否有环, 获得图中的环
